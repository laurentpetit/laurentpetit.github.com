<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Un Petit blog pour Laurent ...]]></title>
  <link href="http://laurentpetit.github.com/atom.xml" rel="self"/>
  <link href="http://laurentpetit.github.com/"/>
  <updated>2013-02-06T00:39:43+01:00</updated>
  <id>http://laurentpetit.github.com/</id>
  <author>
    <name><![CDATA[Laurent Petit]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code Story, Clojure et moi]]></title>
    <link href="http://laurentpetit.github.com/blog/2013/02/04/code-story/"/>
    <updated>2013-02-04T00:11:00+01:00</updated>
    <id>http://laurentpetit.github.com/blog/2013/02/04/code-story</id>
    <content type="html"><![CDATA[<p>Cet article est le premier d&#8217;une série visant à présenter le langage <a href="http://www.clojure.org">Clojure</a> via l&#8217;implémentation d&#8217;une solution <em>tout Clojure</em> au challenge CodeStory.</p>

<h1>C&#8217;est à quel sujet ?</h1>

<p>J&#8217;ai eu le plaisir de participer et me qualifier à la première phase du concours de programmation <a href="http://code-story.net/2013/01/04/concours-2013.html">Code Story 2013</a>.</p>

<p>Pour y parvenir <strong>j&#8217;ai choisi d&#8217;utiliser le langage <a href="http://www.clojure.org">Clojure</a></strong>.</p>

<p>Je voulais apporter un peu d&#8217;exotisme en utilisant la <strong>programmation fonctionnelle</strong>, pour changer un peu de toutes les contributions qui allaient utiliser le même paradigme impératif (Java, Kotlin, Ceylon, Groovy, Scala, etc.).</p>

<blockquote><p>Ce premier article se concentre sur quelques caractéristiques du concours, et pourquoi Clojure est un langage de choix pour les adresser</p></blockquote>

<h1>Web Services</h1>

<p>Pour participer à l&#8217;épreuve, il fallait mettre en place un serveur Web. <strong>Toutes les questions, y compris les énoncés, ont été envoyées par HTTP GET ou POST.</strong></p>

<p><a href="https://github.com/ring-clojure/ring">Ring</a> est la librairie standard Clojure pour écrire des applications Web. C&#8217;est une abstraction &#8220;minimaliste&#8221; (mais pas simpliste !) d&#8217;un serveur web.</p>

<blockquote><p>Clojure+Ring pour faire une appli Web : c&#8217;est simple, lisible, concis</p></blockquote>

<h1>TDD</h1>

<p>Le déroulement des épreuves imposait un format analogue à la méthodologie <code>TDD</code> (Test-Driven Development) :</p>

<ul>
<li>Envoi d&#8217;un test en boucle sur nos serveurs, jusqu&#8217;à obtention d&#8217;une réponse correcte</li>
<li>Complexification incrémentale des tests envoyés</li>
</ul>


<p>Dans ces conditions, il n&#8217;est pas rare (ni anormal) d&#8217;avoir à réécrire de grandes portions de code.
<em>Une étape de refactoring entre chaque nouveau test est généralement nécessaire en TDD</em></p>

<p><strong>Il est naturel d&#8217;adopter l&#8217;approche TDD en Clojure</strong>, car le langage :</p>

<ul>
<li><strong>Facilite l&#8217;écriture des tests</strong> : les tests sont concis, lisibles, faciles à refactorer.</li>
<li><strong>Facilite l&#8217;écriture du code</strong> : écrire du nouveau code en Clojure est une danse entre l&#8217;éditeur et l&#8217;environnement dynamique d&#8217;exécution. Tout nouveau code est façonné / testé dans l&#8217;environnement d&#8217;exécution. Imaginez le remplacement à chaud du mode Debug de votre IDE, <em>&#8220;on steroïds&#8221;</em>.</li>
<li><strong>Favorise le refactoring</strong> : le code Clojure est généralement très concis. Souvent 3 à 10 fois plus concis que son équivalent Java, par exemple. La masse de code à modifier fait moins peur. De plus, l&#8217;unité de réutilisation de code étant la fonction, et non la classe, le code est naturellement plus facile à refactorer.</li>
</ul>


<blockquote><p>Clojure pour faire du TDD, c&#8217;est efficace, lisible, simple, concis</p></blockquote>

<h1>Performances</h1>

<p>Le dernier exercice du concours a soumis nos méninges à rude épreuve. Il ne suffisait pas d&#8217;avoir un code qui fonctionne, il fallait trouver un code &#8220;performant&#8221;.</p>

<p>Mais pas <em>&#8220;Performant&#8221;</em> comme dans &#8220;comment gagner quelques microsecondes dans l&#8217;exécution d&#8217;une requête portant sur quelques éléments à traiter&#8221;. NON. <em>&#8220;Performant&#8221;</em> comme dans &#8220;écrire un algorithme pouvant traiter une requête portant sur plusieurs centaines de milliers, ou des millions, d&#8217;éléments&#8221;.</p>

<p>Pour cette épreuve, écrire un algorithme récursif &#8220;naïf&#8221;, puis tenter des optimisations locales dessus, c&#8217;était un peu comme être sur le Titanic pendant le naufrage, à s&#8217;acharner à graisser les portes de la salle de réception. Ça occupe, mais ça ne sert à rien. Au-delà de 100 entrées, un algo &#8220;naïf&#8221; prenait déjà plusieurs dizaines de secondes. <strong>Pour CodeStory, il fallait être capable de traiter des requêtes de 50.000 éléments ou plus</strong> ! On attend toujours que les algorithmes récursifs aient fini de répondre &#8230; (<a href="https://twitter.com/CodeStory/status/297268190566813696">pauvres chatons</a>)</p>

<blockquote><p>Pour être honnête, sur ce genre de problème, le langage de programmation importe peu</p></blockquote>

<p>Si vous n&#8217;avez pas le bon algorithme, aucun langage ni aucun ordinateur si puissant soit-il ne vous viendra en aide : vous n&#8217;y arriverez pas.
Un algorithme de complexité algorithmique quasi linéaire (dont le temps de réponse est proportionnel, ou légèrement proportionnel au nombre d&#8217;éléments à traiter) l&#8217;emportera haut la main sur n&#8217;importe quel algorithme de complexité exponentielle, et ce dès que la taille du problème dépassera quelques dizaines d&#8217;éléments.</p>

<p>Là encore, soulignons les <strong>caractéristiques de Clojure qui ont facilité la résolution de ce problème</strong>:</p>

<ul>
<li><strong>Facilité de prototypage</strong> : la librairie de base de Clojure est riche en fonctions de manipulation de collections. Les sort, group-by, max-key, etc. y sont presque toutes !</li>
<li><strong>Facilité de refactoring</strong> : le code produit restant concis, il est facile de le refactorer, d&#8217;en produire une version différente. Le fait de manipuler des fonctions plutôt que des classes est un accélérateur de ce phénomène.</li>
<li><strong>Code performant</strong> : à algorithme identique, il reste important que le langage utilisé ne soit pas extrêmement plus lent que les langages &#8220;concurrents&#8221;. En utilisant du Clojure &#8220;idiomatique&#8221;, sans chercher à optimiser, sans compromettre la lisibilité (sous réserve de connaître Clojure et les fonctions standards utilisées, oeuf de course), le code produit s&#8217;est avéré du même ordre de grandeur que les solutions concurrentes. En moyenne seulement 2, parfois 3 fois moins rapide. Il serait possible d&#8217;optimiser pour aller &#8220;talonner&#8221; les langages impératifs (utilisation de tableaux, par ex.), mais c&#8217;était juste non requis, donc non nécessaire.</li>
</ul>


<h1>C&#8217;est tout pour aujourd&#8217;hui</h1>

<p>Si ce premier article vous a mis l&#8217;eau à la bouche, et que vous souhaitez que je continue la série avec des articles techniques et du code, envoyez-moi un petit mot d&#8217;encouragement :-).</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
</feed>
