<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Laurent Petit's Blog]]></title>
  <link href="http://laurentpetit.github.com/atom.xml" rel="self"/>
  <link href="http://laurentpetit.github.com/"/>
  <updated>2013-02-05T01:04:04+01:00</updated>
  <id>http://laurentpetit.github.com/</id>
  <author>
    <name><![CDATA[Laurent Petit]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code Story, Clojure et moi]]></title>
    <link href="http://laurentpetit.github.com/blog/2013/02/04/code-story/"/>
    <updated>2013-02-04T00:11:00+01:00</updated>
    <id>http://laurentpetit.github.com/blog/2013/02/04/code-story</id>
    <content type="html"><![CDATA[<p>J&#8217;ai eu le plaisir de participer et me qualifier à la première phase de <a href="http://code-story.net/2013/01/04/concours-2013.html">Code Story</a>.</p>

<p>Pour y parvenir <strong>j&#8217;ai choisi d&#8217;utiliser le langage <a href="http://www.clojure.org">Clojure</a></strong>.</p>

<p>Je voulais apporter un peu d&#8217;exotisme en utilisant la <strong>programmation fonctionnelle</strong>, pour changer un peu de toutes les contributions qui allaient utiliser le même paradigme impératif (Java, Kotlin, Ceylon, Groovy, etc.).</p>

<blockquote><p>Non, mieux, je voulais porter haut et fort les couleurs de Clojure !</p></blockquote>

<p>Cette série d&#8217;article a pour objectif de faire découvrir Clojure au travers de l&#8217;implémentation d&#8217;une solution au challenge CodeStory.</p>

<p><strong>Ce premier article se concentre sur quelques caractéristiques du concours, et les qualités de Clojure qui ont permis de les adresser.</strong></p>

<h1>Web Services</h1>

<p>Pour participer à l&#8217;épreuve, il fallait mettre en place un serveur Web.</p>

<blockquote><p>Toutes les questions, y compris les énoncés, ont été envoyées par HTTP GET ou POST.</p></blockquote>

<p>Il existe une librairie standard Clojure pour écrire des serveurs Web : (<a href="https://github.com/ring-clojure/ring">Ring</a>). C&#8217;est une abstraction &#8220;minimaliste&#8221; d&#8217;un serveur web, standardisant sous forme de structures de données simples (tableaux associatifs, listes) la requête et la réponse HTTP, et la manière d&#8217;écrire des fonctions handlers (équivalent des servlets) et des middlewares (l&#8217;équivalent des filtres).</p>

<blockquote><p>Ecrire un serveur Web avec le standard Clojure+Ring : simple, concis, lisible.</p></blockquote>

<h1>TDD</h1>

<p>Le déroulement des épreuves imposait un format analogue à la méthodologie <code>TDD</code> (Test Driven Developments) :</p>

<ul>
<li>Envoi d&#8217;un test en boucle sur nos serveurs, jusqu&#8217;à obtention d&#8217;une réponse correcte</li>
<li>Complexification incrémentale des tests envoyés</li>
</ul>


<p>Dans ces conditions, il n&#8217;est pas rare (ni anormal) d&#8217;avoir à réécrire des portions de code à de multiples reprises.</p>

<blockquote><p>Une étape de refactoring entre chaque nouveau test est généralement nécessaire en TDD</p></blockquote>

<p>Développer en TDD avec Clojure est naturel :</p>

<ul>
<li>Facilite l&#8217;écriture des tests : les tests sont concis, lisibles, faciles à refactorer.</li>
<li>Facilite l&#8217;écriture du code : écrire du nouveau code en Clojure est une danse entre l&#8217;éditeur et l&#8217;environnement dynamique d&#8217;exécution. Tout code nouveau est façonné / testé dans l&#8217;environnement d&#8217;exécution. Imaginez le remplacement à chaud du mode Debug de votre IDE, &#8220;on steroïds&#8221;.</li>
<li>Favorise le refactoring : le code Clojure est généralement très concis. Souvent 3 à 10 fois plus concis que son équivalent Java, par ex. La masse de code à modifier fait moins peur. De plus, l&#8217;unité de réutilisation de code étant la fonction, et non la classe, le code est naturellement plus facile à refactorer.</li>
</ul>


<blockquote><p>Clojure pour faire du TDD, c&#8217;est simple, concis, lisible et efficace.</p></blockquote>

<h1>Performances</h1>

<p>La dernièr étape de l&#8217;épreuve a soumis nos méninges à rude épreuve. Il ne suffisait pas d&#8217;avoir un code qui fonctionne, il fallait trouver un code &#8220;performant&#8221;.</p>

<p>Mais pas &#8220;performant&#8221; comme dans &#8220;comment gagner quelques microsecondes dans l&#8217;exécution de ma routine&#8221;. NON. Performant comme dans &#8220;écrire un algorithme qui puisse prendre en charge des centaines de milliers d&#8217;éléments&#8221;.</p>

<p>Pour cette épreuve, écrire un algorithme récursif &#8220;naïf&#8221; puis tenter des optimisations locales dessus revenait à s&#8217;acharner à réparer les portes du Titanic pendant le naufrage. Ca occupe, mais ça ne sert plus à rien. Au-delà de 100 entrées, un algo &#8220;naïf&#8221; prenait déjà plusieurs dizaines de secondes. <strong>Pour CodeStory, il fallait être capable de traiter des requêtes de 50.000 éléments ou plus</strong> ! On attend toujours que les algorithmes récursifs aient fini de répondre &#8230; (pauvres chatons)</p>

<blockquote><p>Pour être honnête, pour ce genre de problème, le langage de programmation importe peu</p></blockquote>

<p>Si vous n&#8217;avez pas le bon algorithme, vous pouvez prendre n&#8217;importe quel langage, et même n&#8217;importe quel ordinateur, vous n&#8217;y arriverez pas.
Un algorithme dont la complexité algorithmique est quasi linéaire l&#8217;emportera haut la main sur n&#8217;importe quel algorithme exponentiel dès que le nombre d&#8217;éléments à traiter grossira un peu.</p>

<p>Là encore, j&#8217;aimerai souligner les caractéristiques de Clojure qui ont facilité la résolution de ce problème:</p>

<ul>
<li>Facilité de prototypage : la librairie de base de Clojure est riche en fonctions de manipulation de collections. Les sort, group-by, max-key, etc. y sont presque toutes !</li>
<li>Facilité de refactoring : le code produit restant concis, il est facile de le refactorer, d&#8217;en produire une version différente. Le fait de manipuler des fonctions plutôt que des classes est un accélérateur de ce phénomène.</li>
<li>Code performant : et oui, même avec le bon algo, il reste important quand même que le langage utilisé ne soit pas un voire plusieurs ordres de grandeur moins performant que les langages concurrents. En utilisant du Clojure &#8220;idiomatique&#8221;, sans chercher à optimiser, sans compromettre la lisibilité (sous réserve de connaître Clojure et les fonctions standards utilisées, oeuf de course), le code produit s&#8217;est avéré du même ordre de grandeur que les solutions concurrentes. En moyenne seulement 2, parfois 3 fois moins rapide. Il serait possible d&#8217;optimiser pour aller &#8220;talonner&#8221; les langages impératifs (utilisation de tableaux, par ex.), mais c&#8217;était juste non requis, donc non nécessaire.</li>
</ul>


<h1>C&#8217;est tout pour aujourd&#8217;hui</h1>

<p>Si ce premier article vous a mis l&#8217;eau à la bouche, et que vous souhaitez que je continue la série avec des articles techniques et du code, faites-le moi savoir.</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
</feed>
